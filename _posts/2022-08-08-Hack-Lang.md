---
toc: true
layout: post
description: Notes on Hack Lang
categories: [hacklang]
title: Hack Lang Notes
comments: false
---



# Types
## Generic Types:

```hack
class StackUnderflowException extends \Exception {}

class Stack<T> {
  private vec<T> $stack;
  private int $stackPtr;

  public function __construct() {
    $this->stackPtr = 0;
    $this->stack = vec[];
  }

  public function push(T $value): void {
    $this->stack[] = $value;
    $this->stackPtr++;
  }

  public function pop(): T {
    if ($this->stackPtr > 0) {
      $this->stackPtr--;
      return $this->stack[$this->stackPtr];
    } else {
      throw new StackUnderflowException();
    }
  }
}

function use_int_stack(Stack<int> $stInt): void {
  $stInt->push(10);
  $stInt->push(20);
  $stInt->push(30);
  echo 'pop => '.$stInt->pop()."\n";
}
```


## Nullable Types

A type ?Foo is either a value of type Foo, or null.

```hack
function takes_nullable_str2(?string $s): string {
  if ($s is nonnull){
    return $s;
  } else {
    return "default";
  }
}
```

## Type Alias
```hack
type Complex = shape('real' => float, 'imag' => float);
newtype Point = (float, float);

function create_Point(float $x, float $y): Point {
  return tuple($x, $y);
}

function distance(Point $p1, Point $p2): float {
  $dx = $p1[0] - $p2[0];
  $dy = $p1[1] - $p2[1];
  return \sqrt($dx*$dx + $dy*$dy);
}
```

`newtype Counter as int = int;`

The presence of the type constraint as int allows the opaque type to be treated as if it had the type specified by that type constraint, which removes some of the alias' opaqueness

```hack
class C {
  const type T2 as arraykey = int;
  ...
}
```
we have a class-specific type constant that is an alias, which allows a value of type T2 to be used in any context an arraykey is expected. After all, any int value is also an arraykey value.

